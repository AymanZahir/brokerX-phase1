# ADR-004 — Conformité & audit exactly-once / effectively-once

**Statut**: Accepté

## Contexte
Le cahier de charge phase 2 impose une traçabilité réglementaire complète (KYC/AML, ordres, exécutions) avec la garantie que chaque action sensible est journalisée **exactement une fois** (ou de façon *effectively-once* malgré les retries). Les UC critiques (inscription, dépôts, ordres, matching, notifications) doivent produire un audit immuable exploitable par le back-office et répondre aux exigences d’accountability. Le prototype monolithique de phase 1 reposait essentiellement sur des journaux applicatifs et ne couvrait pas :

- La distinction claire entre traitements **idempotents** et événements d’audit immuables.
- Les enchaînements multi-étapes (ordre → matching → notification) nécessitant une corrélation forte.
- La présence d’une API Gateway/load balancer pouvant rejouer une requête.

## Décision
Mettre en place une stratégie combinant **exactly-once** pour les écritures métier et **effectively-once** pour les notifications :

1. **Transactions ACID et contraintes uniques** :
   - Les UC sensibles utilisent une transaction unique capturant écriture métier + audit (`@Transactional`).
   - Clés d’idempotence obligatoires (`clientRequestId`, `idempotencyKey`, `clientOrderId`) avec contraintes uniques.
2. **Journal d’audit append-only** :
   - Table dédiée `audit_event` (Flyway V8) stockant `eventId (UUID)`, `traceId`, `actor`, `uc`, `payload JSONB`, `hash`.
   - Les services écrivent un événement pour chaque transition (signup, deposit, order, execution, notification) avec horodatage UTC.
3. **Corrélation distribuée** :
   - Propagation d’un `traceId` généré côté API (filtre + Gateway) et persistance dans les audit events.
   - Les notifications réutilisent `executionId` + `traceId` pour assurer *effectively-once* (retraits via `notification_idempotency`).
4. **Relecture/conciliation** :
   - Scripts `scripts/audit/reconcile.sh` (à produire) permettant de vérifier cohérence `orders` ↔ `executions` ↔ `notifications`.
   - Export CSV/JSON signé (`sha256`) pour back-office.

## Conséquences
- **Robustesse** : un retry HTTP (depuis Gateway/LB) retrouve systématiquement la réponse initiale, les écritures restent uniques.
- **Observabilité** : le `traceId` partagé facilite l’investigation (Grafana/Loki ↔ audit DB).
- **Coût** : surcharge légère sur la base (table audit + index), nécessité d’un schéma Flyway supplémentaire et d’un stockage plus volumineux.
- **Processus** : exige discipline sur l’ajout de toute nouvelle UC (clé d’idempotence + audit event), et revues de code orientées conformité.
- **Interop** : simplifie la future migration microservices (audit central déjà structuré, propagation traceId standardisée).
