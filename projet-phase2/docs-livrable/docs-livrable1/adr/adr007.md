# ADR-007 — Appariement événementiel avec outbox + saga chorégraphiée

**Statut**: Accepté

## Contexte
La phase 3 impose un style événementiel pour l’UC-07 (*Matching interne & exécution*), capable de vivre dans un environnement microservices. Nous devons découpler le placement d’ordre du moteur de matching, tout en garantissant la fiabilité (pas de perte d’événement) et la traçabilité pour les Golden Signals.

## Décision
- Introduire un **outbox** persistant (`outbox_events`) pour journaliser chaque événement métier (type, payload JSON, status, horodatage).
- Mettre en place un **DomainEventBus** en mémoire qui sérialise l’événement dans l’outbox puis le **dispatch** aux handlers enregistrés. Les handlers peuvent publier d’autres événements (choreography).
- Définir des événements `ORDER_PLACED` → `ORDER_MATCHED` avec des payloads dédiés (`OrderPlacedEvent`, `OrderMatchedEvent`).
- Implémenter un handler `MatchingSagaHandler` qui réagit à `ORDER_PLACED`, appelle le moteur `MatchOrders`, publie `ORDER_MATCHED` et laisse la notification/audit existants réagir.
- Injecter `DomainEventPublisher` dans le cas d’usage `PlaceOrder` (et futures mutations d’ordre) pour déclencher la saga tout en retournant un ACK synchronisé.

## Conséquences
- **Découplage** : la couche web n’appelle plus directement le matching ; l’évolution vers des consommateurs asynchrones (Kafka/RabbitMQ) se fait en remplaçant le bus.
- **Fiabilité** : l’outbox sert de trace durable et de point de resynchronisation (replay possible via un dispatcher périodique).
- **Observabilité** : chaque événement est horodaté, ce qui permet de suivre la latence end-to-end et d’alimenter les Golden Signals.
- **Complexité** : nécessite la supervision du stock `outbox_events` et la gestion des erreurs de handler (statut `FAILED`), à monitorer dans les dashboards.
